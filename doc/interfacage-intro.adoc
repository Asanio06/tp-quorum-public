=== Contexte

==== Workflow

L'utilisation d'Ethereum (au lieu de Quorum) poserait plusieurs soucis pour une
utilisation réelle, notamment de confidentialité des données.
En effet, les livraisons d'un éleveur à la laiterie ne doivent pas être connues
de tous les autres éleveurs aussi !

WARNING: Quorum impose de connaître en amont la
*liste intégrale des participants impliqués* car il n'est pas possible avec
Quorum d'ajouter à postériori des participants pour qu'ils rejoignent un
smart-contract déjà déployé (Quorum ne propage pas les anciennes transactions).

Deux smart-contracts seront utilisés conjointement pour permettre d'implémenter
le workflow illustré par le schéma qui suit :

* ```MilkDelivery``` : garde trace des livraisons de lait et est en mode privé
  entre l'éleveur qui procède à l'envoi, la laiterie qui reçoit le lait et la
  coopérative.
* ```DairyProduction``` : est lié à toutes les smart-contracts ```MilkDelivery```
  et est en mode privé entre la laiterie qui fabrique le fromage et la
  coopérative.

[plantuml,interfacage-workflow,svg,align=center]
----
@startuml
actor "Eleveur 1"
actor "Eleveur 2"
actor Laiterie
database "MilkDelivery #1" << smart-contract >>
database "MilkDelivery #2" << smart-contract >>
database "DairyProduction #1" << smart-contract >>
database "AddressBook" << smart-contract >>

group Livraison du 1er éleveur
  "Eleveur 1"  -> "MilkDelivery #1": sendMilk(quantity)
  activate "MilkDelivery #1"
  "Eleveur 1" <-- "MilkDelivery #1": deliveryID #1
  Laiterie -> "MilkDelivery #1": validateDelivery(deliveryID #1)
  "Eleveur 1"  -> "MilkDelivery #1": validateDelivery()
end

group Livraison du 2nd éleveur
  "Eleveur 2"  -> "MilkDelivery #2": sendMilk(quantity)
  activate "MilkDelivery #2"
  "Eleveur 2" <-- "MilkDelivery #2": deliveryID #2
  Laiterie -> "MilkDelivery #2": validateDelivery(deliveryID #2)
end

group Fabrication du fromage
  Laiterie  -> "DairyProduction #1": makeCheese(quantity, deliveryID #1, deliveryID #2)
  activate "DairyProduction #1"
  Laiterie <-- "DairyProduction #1": cheeseProducedID
  "DairyProduction #1" -> "MilkDelivery #1": consumed()
  destroy "MilkDelivery #1"
  "DairyProduction #1" -> "MilkDelivery #2": consumed()
  destroy "MilkDelivery #2"
end

group Délivrance du label AOP
  Laiterie  -> "DairyProduction #1": checkGeoBoundaries()
  "DairyProduction #1" -> AddressBook: checkGeoBoundaries(Eleveur 1)
  activate AddressBook
  "DairyProduction #1" -> AddressBook: checkGeoBoundaries(Eleveur 2)
  "DairyProduction #1" -> AddressBook: checkGeoBoundaries(Laiterie)
  Laiterie <-- "DairyProduction #1": acception ou non de délivrance du label
  deactivate AddressBook
  deactivate "DairyProduction #1"
end

@enduml
----

==== Mises en garde

La mise en oeuvre qui va être faite dans ce TP n'est pas très représentative
de ce qu'on ferait normalement. Par simplicité, nous allons
considérer qu'il n'y a qu'une seule instance d'un front-end (disons mis à
disposition par la coopérative) et que les identifiants de connexion sont
superflus (nous pourrons changer de compte par un menu du site web).

Une architecture plus traditionnelle serait d'utiliser des containers
Docker (front-end, back-end / API, base NoSQL/cache, Quorum si pas porté par
Kaleido, etc.) et que chaque acteur fasse tourner cette stack technique
intégralement sur son infrastructure, Quorum étant en charge de la
_synchronisation_ des données entre les acteurs.

.Architecture _traditionnelle_ avec des DLT
[svgbob,architecture-production,svg,align=center]
----
        ,-.                    ,-.                    ,-.
        `-'                    `-'                    `-'
        /|\                    /|\                    /|\
         |                      |                      |
        / \                    / \                    / \

         ^                      ^                      ^
         |                      |                      |
         |                      |                      |
.----- Docker ----.    .----- Docker ----.    .----- Docker ----.
|        |        |    |        |        |    |        |        |
|        v        |    |        v        |    |        v        |
|  .-----------.  |    |  .-----------.  |    |  .-----------.  |
|  | Front-end |  |    |  | Front-end |  |    |  | Front-end |  |
|  '-----------'  |    |  '-----------'  |    |  '-----------'  |
|        ^        |    |        ^        |    |        ^        |
|        |        |    |        |        |    |        |        |
|        v        |    |        v        |    |        v        |
|  .-----------.  |    |  .-----------.  |    |  .-----------.  |
|  | Back-end  |  |    |  | Back-end  |  |    |  | Back-end  |  |
|  '-----------'  |    |  '-----------'  |    |  '-----------'  |
|     ^     ^     |    |     ^     ^     |    |     ^     ^     |
|     |     |     |    |     |     |     |    |     |     |     |
|     |     v     |    |     |     v     |    |     |     v     |
|     | .-------. |    |     | .-------. |    |     | .-------. |
|     | | Cache | |    |     | | Cache | |    |     | | Cache | |
|     | '-------' |    |     | '-------' |    |     | '-------' |
|     v           |    |     v           |    |     v           |
|  .-----------.  |    |  .-----------.  |    |  .-----------.  |
|  |  Quorum   |<========>|  Quorum   |<========>|  Quorum   |  |
|  '-----------'  |    |  '-----------'  |    |  '-----------'  |
|                 |    |                 |    |                 |
`-----------------'    `-----------------'    `-----------------'
   Participant 1          Participant 2    ...   Participant n


----

==== Présentation du squelette d'application

Afin de vous faire gagner du temps et de vous concentrer sur des développements
liés à la blockchain, un squelette d'application vous sera fourni.
Le squelette de cette application contient plusieurs choses notables :

* un front-end dont le code est présent dans le dossier `src`
* un squelette de back-end dont le code est présent dans le dossier `api`
* des squelettes de smarts-contracts dans le dossier `contracts`
